"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const puppeteer = require("puppeteer");
const chalk_1 = require("chalk");
const build_sandboxes_1 = require("../build-sandboxes");
const error_reporter_1 = require("../error-reporter");
const utils_1 = require("../utils");
// Used to tailor the version of headless chromium ran by puppeteer
const CHROME_ARGS = ['--disable-gpu', '--no-sandbox'];
let browser;
let currentScenario = '';
let currentScenarioDescription = '';
let reporter;
// Ensure Chromium instances are destroyed on error
process.on('unhandledRejection', () => __awaiter(void 0, void 0, void 0, function* () {
    if (browser) {
        yield browser.close();
    }
}));
function verifySandboxes(config) {
    return __awaiter(this, void 0, void 0, function* () {
        yield main(config);
    });
}
exports.verifySandboxes = verifySandboxes;
/////////////////////////////////
function main(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const hostUrl = `http://localhost:${config.angularCliPort}`;
        const timeoutAttempts = config.timeout;
        browser = yield puppeteer.launch({
            headless: true,
            handleSIGINT: false,
            args: CHROME_ARGS,
        });
        yield utils_1.waitForNgServe(browser, hostUrl, timeoutAttempts);
        const scenarios = getSandboxMetadata(config, hostUrl, config.randomScenario);
        console.log(`Retrieved ${scenarios.length} scenarios.\n`);
        reporter = new error_reporter_1.ErrorReporter(scenarios, config.reportPath, config.reportType);
        const page = yield setupPageAndErrorHandling(hostUrl);
        for (let i = 0; i < scenarios.length; i++) {
            console.log(`Checking [${i + 1}/${scenarios.length}]: ${scenarios[i].name}: ${scenarios[i].description}`);
            yield openScenario(scenarios[i], page);
        }
        yield page.close();
        yield browser.close();
        const hasErrors = reporter.errors.length > 0;
        // always generate report if report type is a file, or if there are errors
        if (hasErrors || config.reportType !== error_reporter_1.REPORT_TYPE.LOG) {
            reporter.compileReport();
        }
        const exitCode = hasErrors ? 1 : 0;
        process.exit(exitCode);
    });
}
function setupPageAndErrorHandling(hostUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        const page = yield browser.newPage();
        page.on('console', (msg) => onConsoleErr(msg));
        yield page.goto(hostUrl);
        return page;
    });
}
function openScenario(scenario, page) {
    return __awaiter(this, void 0, void 0, function* () {
        currentScenario = scenario.name;
        currentScenarioDescription = scenario.description;
        // @ts-ignore
        yield page.evaluate((sandboxKey, scenarioKey) => window.loadScenario(sandboxKey, scenarioKey), scenario.sandboxKey, scenario.scenarioKey);
        // @ts-ignore
        yield page.waitFor(() => window.isPlaygroundComponentLoaded() || window.isPlaygroundComponentLoadedWithErrors());
        const sleep = (ms) => new Promise(res => setTimeout(res, ms));
        yield sleep(100); // sleep for a bit in case page elements are still being rendered
    });
}
/**
 * Retrieves Sandbox scenario URLs, descriptions, and names
 * @param config - Configuration
 * @param baseUrl - Base URL of scenario path e.g. http://localhost:4201
 * @param selectRandomScenario - Whether or not to select one random scenario of all availalble scenarios for a component
 */
function getSandboxMetadata(config, baseUrl, selectRandomScenario) {
    const scenarios = [];
    loadSandboxMenuItems().forEach((sandboxItem) => {
        if (!config.pathToSandboxes || config.pathToSandboxes.some(vp => sandboxItem.key.includes(vp))) {
            if (selectRandomScenario) {
                const randomItemKey = getRandomKey(sandboxItem.scenarioMenuItems.length);
                for (const item of sandboxItem.scenarioMenuItems) {
                    if (item.key === randomItemKey) {
                        scenarios.push({
                            name: sandboxItem.key,
                            description: item.description,
                            sandboxKey: sandboxItem.key,
                            scenarioKey: item.key
                        });
                        break;
                    }
                }
            }
            else {
                // Grab all scenarios
                sandboxItem.scenarioMenuItems
                    .forEach((item) => {
                    scenarios.push({
                        name: sandboxItem.key,
                        description: item.description,
                        sandboxKey: sandboxItem.key,
                        scenarioKey: item.key
                    });
                });
            }
        }
    });
    return scenarios;
}
/**
 * Attempt to load sandboxes.ts and provide menu items
 */
function loadSandboxMenuItems() {
    try {
        return require(build_sandboxes_1.SANDBOX_MENU_ITEMS_FILE).getSandboxMenuItems();
    }
    catch (err) {
        throw new Error(`Failed to load sandbox menu items. ${err}`);
    }
}
/**
 * Callback when Chromium page encounters a console error
 */
function onConsoleErr(msg) {
    if (msg.type() === 'error') {
        console.error(chalk_1.default.red(`Error in ${currentScenario} (${currentScenarioDescription}):`));
        const getErrors = (type, getValue) => msg.args()
            .map(a => a._remoteObject)
            .filter(o => o.type === type)
            .map(getValue);
        const stackTrace = getErrors('object', o => o.description);
        const errorMessage = getErrors('string', o => o.value);
        const description = stackTrace.length ? stackTrace : errorMessage;
        description.map(d => console.error(d));
        if (description.length) {
            reporter.addError(description, currentScenario, currentScenarioDescription);
        }
    }
}
/**
 * Returns a random value between 1 and the provided length (both inclusive).
 * Note: indexing of keys starts at 1, not 0
 */
function getRandomKey(menuItemsLength) {
    return Math.floor(Math.random() * menuItemsLength) + 1;
}
