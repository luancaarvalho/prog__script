"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const from_dir_1 = require("./from-dir");
const string_builder_1 = require("./string-builder");
exports.SANDBOX_MENU_ITEMS_FILE = path_1.resolve(__dirname, './sandbox-menu-items.js');
function buildSandboxes(srcPaths, chunk, makeSandboxMenuItemFile = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const chunkMode = chunk ? 'lazy' : 'eager';
        const homes = srcPaths.map(srcPath => path_1.resolve(srcPath));
        const sandboxes = findSandboxes(homes);
        if (makeSandboxMenuItemFile) {
            yield buildSandboxMenuItemFile(sandboxes);
        }
        const rootPaths = [path_1.resolve(__dirname, '../playground')];
        const ivyRootPath = path_1.resolve(__dirname, '../../__ivy_ngcc__');
        if (fs_1.existsSync(ivyRootPath)) {
            rootPaths.push(ivyRootPath);
        }
        return yield buildSandboxFileContents(rootPaths, sandboxes, chunkMode, writeSandboxContent).then(results => {
            console.log('Successfully compiled sandbox files.');
            return results;
        });
    });
}
exports.buildSandboxes = buildSandboxes;
function findSandboxes(homes) {
    const sandboxes = [];
    from_dir_1.fromDirMultiple(homes, /\.sandbox.ts$/, (filename, home) => {
        const sandboxPath = filename.replace(home, '.').replace(/.ts$/, '').replace(/\\/g, '/');
        const contents = fs_1.readFileSync(filename, 'utf8');
        const matchSandboxOf = /\s?sandboxOf\s*\(\s*([^)]+?)\s*\)/g.exec(contents);
        if (matchSandboxOf) {
            const typeName = matchSandboxOf[1].split(',')[0].trim();
            const labelText = /label\s*:\s*['"](.+)['"]/g.exec(matchSandboxOf[0]);
            const uniqueIdText = /uniqueId\s*:\s*['"](.+)['"]/g.exec(matchSandboxOf[0]);
            const scenarioMenuItems = [];
            // Tested with https://regex101.com/r/mtp2Fy/2
            // First scenario: May follow directly after sandboxOf function ).add
            // Other scenarios: .add with possible whitespace before. Ignore outcommented lines.
            const scenarioRegex = /^(?!\/\/)(?:\s*|.*\))\.add\s*\(\s*['"](.+)['"]\s*,\s*{/gm;
            let scenarioMatches;
            let scenarioIndex = 1;
            while ((scenarioMatches = scenarioRegex.exec(contents)) !== null) {
                scenarioMenuItems.push({ key: scenarioIndex, description: scenarioMatches[1] });
                scenarioIndex++;
            }
            const label = labelText ? labelText[1] : '';
            sandboxes.push({
                key: sandboxPath,
                uniqueId: uniqueIdText ? uniqueIdText[1] : undefined,
                srcPath: home,
                searchKey: `${typeName}${label}`,
                name: typeName,
                label,
                scenarioMenuItems,
            });
        }
    });
    return sandboxes;
}
exports.findSandboxes = findSandboxes;
function writeSandboxContent(filePath, fileContent) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            fs_1.writeFile(filePath, fileContent, err => {
                if (err) {
                    reject(new Error('Unable to compile sandboxes.'));
                }
                resolve(filePath);
            });
        });
    });
}
function buildSandboxFileContents(rootPaths, sandboxes, chunkMode, writeContents) {
    const promises = [];
    from_dir_1.fromDirMultiple(rootPaths, /angular-playground.*\.js/, (filename) => {
        let contents = fs_1.readFileSync(filename, 'utf8');
        if (contents.indexOf('*GET_SANDBOX*') !== -1) {
            const sandboxMenuItemsMethodBody = buildGetSandboxMenuItemMethodBodyContent(sandboxes);
            contents = contents.replace(/(\/\*GET_SANDBOX_MENU_ITEMS\*\/).*?(?=\/\*END_GET_SANDBOX_MENU_ITEMS\*\/)/s, `$1\n ${sandboxMenuItemsMethodBody} \n`);
            const sandboxMethodBody = buildGetSandboxMethodBodyContent(sandboxes, chunkMode);
            contents = contents.replace(/(\/\*GET_SANDBOX\*\/).*?(?=\/\*END_GET_SANDBOX\*\/)/s, `$1\n ${sandboxMethodBody} \n`);
            promises.push(writeContents(filename, contents));
        }
    });
    return Promise.all(promises);
}
exports.buildSandboxFileContents = buildSandboxFileContents;
function buildGetSandboxMethodBodyContent(sandboxes, chunkMode) {
    const content = new string_builder_1.StringBuilder();
    content.addLine(`switch(path) {`);
    sandboxes.forEach(({ key, srcPath }, i) => {
        let fullPath = path_1.join(srcPath, key);
        // Normalize slash syntax for Windows/Unix filepaths
        fullPath = slash(fullPath);
        content.addLine(`case '${key}':`);
        content.addLine(`  return import( /* webpackMode: "${chunkMode}" */ '${fullPath}').then(function(_){ return _.default.serialize('${key}'); });`);
    });
    content.addLine(`}`);
    return content.dump();
}
exports.buildGetSandboxMethodBodyContent = buildGetSandboxMethodBodyContent;
function buildGetSandboxMenuItemMethodBodyContent(sandboxes) {
    return `return ${JSON.stringify(sandboxes)};`;
}
exports.buildGetSandboxMenuItemMethodBodyContent = buildGetSandboxMenuItemMethodBodyContent;
function buildSandboxMenuItemFile(sandboxes) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = new string_builder_1.StringBuilder();
        content.addLine(`function getSandboxMenuItems() {`);
        content.addLine(`return ${JSON.stringify(sandboxes)};`);
        content.addLine(`}`);
        content.addLine('exports.getSandboxMenuItems = getSandboxMenuItems;');
        yield writeSandboxContent(exports.SANDBOX_MENU_ITEMS_FILE, content.dump());
    });
}
exports.buildSandboxMenuItemFile = buildSandboxMenuItemFile;
// Turns windows URL string ('c:\\etc\\') into URL node expects ('c:/etc/')
// https://github.com/sindresorhus/slash
function slash(input) {
    const isExtendedLengthPath = /^\\\\\?\\/.test(input);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(input);
    if (isExtendedLengthPath || hasNonAscii) {
        return input;
    }
    return input.replace(/\\/g, '/');
}
exports.slash = slash;
