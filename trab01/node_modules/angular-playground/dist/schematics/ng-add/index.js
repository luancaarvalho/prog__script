"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const config_1 = require("@schematics/angular/utility/config");
const npm_script_1 = require("../utils/npm-script");
const project_1 = require("../utils/project");
const workspace_models_1 = require("@schematics/angular/utility/workspace-models");
const paths_1 = require("../utils/paths");
function add(options) {
    return schematics_1.chain([
        updateNpmConfig(),
        configure(options),
        createNewFiles(options),
    ]);
}
exports.default = add;
function updateNpmConfig() {
    return (host) => {
        npm_script_1.addNpmScriptToPackageJson(host, 'playground', 'angular-playground');
        return host;
    };
}
exports.updateNpmConfig = updateNpmConfig;
function addAppToWorkspaceFile(options, workspace, project, packageName) {
    const projectRoot = core_1.normalize(project.root);
    const projectRootParts = projectRoot.split('/');
    const sourceRoot = project_1.getSourceRoot(project.sourceRoot);
    const sourceRootParts = sourceRoot.split('/');
    const newProject = {
        root: projectRoot,
        sourceRoot,
        projectType: workspace_models_1.ProjectType.Application,
        architect: {
            build: {
                builder: workspace_models_1.Builders.Browser,
                options: {
                    outputPath: paths_1.constructPath(['dist', 'playground']),
                    index: paths_1.constructPath([...sourceRootParts, 'index.html']),
                    main: paths_1.constructPath([...sourceRootParts, 'main.playground.ts']),
                    polyfills: paths_1.constructPath([...sourceRootParts, 'polyfills.ts']),
                    tsConfig: paths_1.constructPath([...projectRootParts, `tsconfig.playground.json`]),
                    aot: false,
                    assets: [
                        paths_1.constructPath([...sourceRootParts, 'favicon.ico']),
                        paths_1.constructPath([...sourceRootParts, 'assets']),
                    ],
                    styles: [
                        paths_1.constructPath([...sourceRootParts, `styles.${options.stylesExtension}`]),
                    ],
                    scripts: [],
                },
                configurations: {
                    production: {
                        fileReplacements: [
                            {
                                replace: paths_1.constructPath([...sourceRootParts, 'environments', 'environment.ts']),
                                with: paths_1.constructPath([...sourceRootParts, 'environments', 'environment.prod.ts']),
                            },
                        ],
                        optimization: true,
                        outputHashing: 'all',
                        sourceMap: false,
                        extractCss: true,
                        namedChunks: false,
                        extractLicenses: true,
                        vendorChunk: false,
                        buildOptimizer: true,
                    },
                },
            },
            serve: {
                builder: workspace_models_1.Builders.DevServer,
                options: {
                    browserTarget: 'playground:build',
                    port: 4201
                },
            },
        },
    };
    return config_1.addProjectToWorkspace(workspace, packageName, newProject);
}
function configure(options) {
    return (host, context) => {
        const workspace = config_1.getWorkspace(host);
        const project = project_1.getProject(host, options, 'application');
        let stylesExtension = 'css';
        if (project.architect
            && project.architect.build
            && project.architect.build.options
            && project.architect.build.options.styles) {
            const mainStyle = project.architect.build.options.styles
                .find((path) => typeof path === 'string'
                ? path.includes('/styles.')
                : path.input.includes('/styles.'));
            if (mainStyle) {
                const mainStyleString = typeof mainStyle === 'string' ? mainStyle : mainStyle.input;
                stylesExtension = mainStyleString.split('.').pop();
            }
        }
        return schematics_1.chain([
            addAppToWorkspaceFile({ stylesExtension }, workspace, project, 'playground'),
        ])(host, context);
    };
}
function createNewFiles(options) {
    return (host, context) => {
        const project = project_1.getProject(host, options);
        const sourceRoot = project_1.getSourceRoot(project.sourceRoot);
        const angularPlaygroundJsonTemplateSource = schematics_1.apply(schematics_1.url('./files'), [
            schematics_1.filter(path => path.endsWith('angular-playground.json')),
            schematics_1.template(Object.assign(Object.assign({}, core_1.strings), { sourceRoots: [sourceRoot] })),
        ]);
        const tsconfigJsonTemplateSource = schematics_1.apply(schematics_1.url('./files'), [
            schematics_1.filter(path => path.endsWith('tsconfig.playground.json')),
            schematics_1.template({}),
        ]);
        const playgroundMainTemplateSource = schematics_1.apply(schematics_1.url('./files'), [
            schematics_1.filter(path => path.endsWith('main.playground.ts')),
            schematics_1.template({}),
            schematics_1.move(sourceRoot),
        ]);
        return schematics_1.chain([
            schematics_1.branchAndMerge(schematics_1.mergeWith(angularPlaygroundJsonTemplateSource)),
            schematics_1.branchAndMerge(schematics_1.mergeWith(tsconfigJsonTemplateSource)),
            schematics_1.branchAndMerge(schematics_1.mergeWith(playgroundMainTemplateSource)),
        ])(host, context);
    };
}
//# sourceMappingURL=index.js.map