"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const project_1 = require("../../utils/project");
const workspace_models_1 = require("@schematics/angular/utility/workspace-models");
const config_1 = require("@schematics/angular/utility/config");
const paths_1 = require("../../utils/paths");
function migration(options) {
    return schematics_1.chain([
        configure(options),
        updateFiles(options),
    ]);
}
exports.default = migration;
function updateAppInWorkspaceFile(options, workspace, project, packageName) {
    const projectRoot = core_1.normalize(project.root);
    const projectRootParts = projectRoot.split('/');
    const sourceRoot = project_1.getSourceRoot(project.sourceRoot);
    const sourceRootParts = sourceRoot.split('/');
    const playgroundProject = {
        root: projectRoot,
        sourceRoot,
        projectType: workspace_models_1.ProjectType.Application,
        architect: {
            build: {
                builder: workspace_models_1.Builders.Browser,
                options: {
                    outputPath: paths_1.constructPath(['dist', 'playground']),
                    index: paths_1.constructPath([...sourceRootParts, 'index.html']),
                    main: paths_1.constructPath([...sourceRootParts, 'main.playground.ts']),
                    polyfills: paths_1.constructPath([...sourceRootParts, 'polyfills.ts']),
                    tsConfig: paths_1.constructPath([...projectRootParts, `tsconfig.playground.json`]),
                    aot: false,
                    assets: [
                        paths_1.constructPath([...sourceRootParts, 'favicon.ico']),
                        paths_1.constructPath([...sourceRootParts, 'assets']),
                    ],
                    styles: [
                        paths_1.constructPath([...sourceRootParts, `styles.${options.stylesExtension}`]),
                    ],
                    scripts: [],
                },
                configurations: {
                    production: {
                        fileReplacements: [
                            {
                                replace: paths_1.constructPath([...sourceRootParts, 'environments', 'environment.ts']),
                                with: paths_1.constructPath([...sourceRootParts, 'environments', 'environment.prod.ts']),
                            },
                        ],
                        optimization: true,
                        outputHashing: 'all',
                        sourceMap: false,
                        extractCss: true,
                        namedChunks: false,
                        extractLicenses: true,
                        vendorChunk: false,
                        buildOptimizer: true,
                    },
                },
            },
            serve: {
                builder: workspace_models_1.Builders.DevServer,
                options: {
                    browserTarget: 'playground:build',
                    port: 4201
                },
            },
        },
    };
    workspace.projects[packageName] = playgroundProject;
    return config_1.updateWorkspace(workspace);
}
function configure(options) {
    return (host, context) => {
        const workspace = config_1.getWorkspace(host);
        const project = project_1.getProject(host, options, 'application');
        let stylesExtension = 'css';
        if (project.architect
            && project.architect.build
            && project.architect.build.options
            && project.architect.build.options.styles) {
            const mainStyle = project.architect.build.options.styles
                .find((path) => typeof path === 'string'
                ? path.includes('/styles.')
                : path.input.includes('/styles.'));
            if (mainStyle) {
                const mainStyleString = typeof mainStyle === 'string' ? mainStyle : mainStyle.input;
                stylesExtension = mainStyleString.split('.').pop();
            }
        }
        return schematics_1.chain([
            updateAppInWorkspaceFile({ stylesExtension }, workspace, project, 'playground'),
        ])(host, context);
    };
}
function updateFiles(options) {
    return (host, context) => {
        const project = project_1.getProject(host, options);
        const sourceRoot = project_1.getSourceRoot(project.sourceRoot);
        const tsconfigJsonTemplateSource = schematics_1.apply(schematics_1.url('./files'), [
            schematics_1.filter(path => path.endsWith('tsconfig.playground.json')),
            schematics_1.template({}),
            overwriteIfExists(host),
        ]);
        const playgroundMainTemplateSource = schematics_1.apply(schematics_1.url('./files'), [
            schematics_1.filter(path => path.endsWith('main.playground.ts')),
            schematics_1.template({}),
            schematics_1.move(sourceRoot),
            overwriteIfExists(host),
        ]);
        return schematics_1.chain([
            schematics_1.mergeWith(tsconfigJsonTemplateSource),
            schematics_1.mergeWith(playgroundMainTemplateSource),
        ])(host, context);
    };
}
// Add to resolve issue with mergeWith not working when using MergeStrategy.Overwrite
// When not using this function I get this error:  "Error [file] already exists."
// https://github.com/angular/angular-cli/issues/11337#issuecomment-516543220
function overwriteIfExists(host) {
    return schematics_1.forEach(fileEntry => {
        if (host.exists(fileEntry.path)) {
            host.overwrite(fileEntry.path, fileEntry.content);
            return null;
        }
        return fileEntry;
    });
}
//# sourceMappingURL=index.js.map